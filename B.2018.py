MOD = 1000000007

def power_of_two(x):
    result = 1
    base = 2
    while x > 0:
        if x % 2 == 1:
            result = (result * base) % MOD
        base = (base * base) % MOD
        x //= 2
    return result

# Ввод данных
n = int(input())
d = [0] + list(map(int, input().split()))

# Инициализация таблицы dp
dp = [[0, 0] for _ in range(n+1)]

# Начальные условия для первой вершины
dp[1][1] = power_of_two(d[1])

# Заполнение таблицы dp
for i in range(2, n+1):
    # Если вершина `v_i` не входит в покрытие, все `d_i` обязаны быть покрыты.
    # Предыдущая вершина `v_{i-1}` обязана быть в покрытии, так как текущая `v_i` не покрывает смежные с ней ребра
    dp[i][0] = dp[i-1][1] 

    # Если `v_i` входит в покрытие, добавляем все возможные способы покрытия для `d_i` вершин, так как `v_i` уже покрывает все свои ребра
    dp[i][1] = (dp[i-1][0] + dp[i-1][1]) * power_of_two(d[i]) % MOD

# Результат - сумма способов, когда последняя вершина включена или не включена
result = (dp[n][0] + dp[n][1]) % MOD
print(result)
